//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';
import { AnswerCreateDto, AnswerReadDto, CommentCreateDto, CommentReadDto, CommunityCreateDto, CommunityReadDto, CommunityUpdateDto, ProblemDetails, QuestionCreateDto, QuestionReadDto, QuestionTagCreateDto, SavedAnswerDto, TagCreateDto, TagQuestionReadDto, TagReadDto, TagUpdateDto, UserCreateDto, UserReadDto, UserUpdateDto, VoteCreateDto } from '../types';
import { NextResponse } from 'next/server';
import { RedirectType, permanentRedirect } from 'next/navigation';

export interface IClient {
    /**
     * @return Error
     */
    getAllAnswers(): Promise<AnswerReadDto>;
    /**
     * @return Error
     */
    getAnswerById(id: number): Promise<AnswerReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    addAnswer(body: AnswerCreateDto | undefined): Promise<AnswerReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    updateAnswer(id: number, body: AnswerCreateDto | undefined): Promise<AnswerReadDto>;
    /**
     * @return Error
     */
    deleteAnswer(id: number): Promise<AnswerReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    vote(id: number, body: VoteCreateDto | undefined): Promise<VoteCreateDto>;
    /**
     * @return Error
     */
    getAllComments(): Promise<CommentReadDto[]>;
    /**
     * @return Error
     */
    getCommentById(id: number): Promise<CommentReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    addComment(body: CommentCreateDto | undefined): Promise<CommentReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    updateComment(id: number, body: CommentCreateDto | undefined): Promise<ProblemDetails>;
    /**
     * @return Error
     */
    deleteComment(id: number): Promise<ProblemDetails>;
    /**
     * @return Success
     */
    communitiesAll(): Promise<CommunityReadDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    communitiesPOST(body: CommunityCreateDto | undefined): Promise<CommunityReadDto>;
    /**
     * @return Success
     */
    getCommunityById(id: number): Promise<CommunityReadDto>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    communitiesPUT(id: number, body: CommunityUpdateDto | undefined): Promise<CommunityReadDto>;
    /**
     * @return No Content
     */
    communitiesDELETE(id: number): Promise<void>;
    /**
     * @return Error
     */
    getAllQuestion(): Promise<QuestionReadDto[]>;
    /**
     * @return Error
     */
    getQuestionById(id: number): Promise<QuestionReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    createQuestion(body: QuestionCreateDto | undefined): Promise<QuestionReadDto>;
    /**
     * @param body (optional) 
     * @return Error
     */
    updateQuestion(id: number, body: QuestionCreateDto | undefined): Promise<QuestionReadDto>;
    /**
     * @return Error
     */
    delete(id: number): Promise<QuestionReadDto>;
    /**
     * @return Success
     */
    savedanswers(): Promise<SavedAnswerDto[]>;
    /**
     * @return Success
     */
    savedanswerGET(id: number): Promise<SavedAnswerDto>;
    /**
     * @param body (optional) 
     * @return Created
     */
    saveanswer(body: SavedAnswerDto | undefined): Promise<SavedAnswerDto>;
    /**
     * @return No Content
     */
    savedanswerDELETE(id: number): Promise<void>;
    /**
     * @return Error
     */
    getAllTags(): Promise<TagReadDto[]>;
    /**
     * @return Error
     */
    getTagById(id: number): Promise<TagReadDto>;
    /**
     * @param body (optional) 
     * @return Created
     */
    createTag(body: TagCreateDto | undefined): Promise<TagReadDto>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    updateTag(id: number, body: TagUpdateDto | undefined): Promise<TagReadDto>;
    /**
     * @return No Content
     */
    deleteTag(id: number): Promise<void>;
    /**
     * @return Success
     */
    addQuestionTag(body: QuestionTagCreateDto[] | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    deleteQuestionTag(body: QuestionTagCreateDto | undefined): Promise<void>;
    /**
     * @return Success
     */
    usersAll(): Promise<UserReadDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    usersPOST(body: UserCreateDto | undefined): Promise<UserReadDto>;
    /**
     * @return Success
     */
    getUserById(id: number): Promise<UserReadDto>;
    /**
     * @param body (optional) 
     * @return No Content
     */
    usersPUT(id: number, body: UserUpdateDto | undefined): Promise<void>;
    /**
     * @return No Content
     */
    usersDELETE(id: number): Promise<void>;
}

export class Client implements IClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Error
     */
    getAllAnswers( cancelToken?: CancelToken | undefined): Promise<AnswerReadDto> {
        let url_ = this.baseUrl + "/Answers/GetAllAnswers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAnswers(_response);
        });
    }

    protected processGetAllAnswers(response: AxiosResponse): Promise<AnswerReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<AnswerReadDto>(resultdefault);

        }
    }

    /**
     * @return Error
     */
    getAnswerById(id: number, cancelToken?: CancelToken | undefined): Promise<AnswerReadDto> {
        let url_ = this.baseUrl + "/Answers/GetAnswerById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAnswerById(_response);
        });
    }

    protected processGetAnswerById(response: AxiosResponse): Promise<AnswerReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<AnswerReadDto>(resultdefault);

        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    addAnswer(body: AnswerCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<AnswerReadDto> {
        let url_ = this.baseUrl + "/Answers/AddAnswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddAnswer(_response);
        });
    }

    protected processAddAnswer(response: AxiosResponse): Promise<AnswerReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<AnswerReadDto>( response.data);
        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    updateAnswer(id: number, body: AnswerCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<AnswerReadDto> {
        let url_ = this.baseUrl + "/Answers/UpdateAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAnswer(_response);
        });
    }

    protected processUpdateAnswer(response: AxiosResponse): Promise<AnswerReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<AnswerReadDto>(resultdefault);

        }
    }

    /**
     * @return Error
     */
    deleteAnswer(id: number, cancelToken?: CancelToken | undefined): Promise<AnswerReadDto> {
        let url_ = this.baseUrl + "/Answers/DeleteAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAnswer(_response);
        });
    }

    protected processDeleteAnswer(response: AxiosResponse): Promise<AnswerReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<AnswerReadDto>(resultdefault);

        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    vote(id: number, body: VoteCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<VoteCreateDto> {
        let url_ = this.baseUrl + "/Answers/VoteHandle/{id}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVote(_response);
        });
    }

    protected processVote(response: AxiosResponse): Promise<VoteCreateDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            
            return Promise.resolve<VoteCreateDto>(response.data);

        }
    }

    /**
     * @return Error
     */
    getAllComments( cancelToken?: CancelToken | undefined): Promise<CommentReadDto[]> {
        let url_ = this.baseUrl + "/Comment/GetAllComments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllComments(_response);
        });
    }

    protected processGetAllComments(response: AxiosResponse): Promise<CommentReadDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<CommentReadDto[]>(response.data);
        }
    }

    /**
     * @return Error
     */
    getCommentById(id: number, cancelToken?: CancelToken | undefined): Promise<CommentReadDto> {
        let url_ = this.baseUrl + "/Comment/GetCommentById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommentById(_response);
        });
    }

    protected processGetCommentById(response: AxiosResponse): Promise<CommentReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<CommentReadDto>(resultdefault);

        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    addComment(body: CommentCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<CommentReadDto> {
        let url_ = this.baseUrl + "/Comment/AddComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddComment(_response);
        });
    }

    protected processAddComment(response: AxiosResponse): Promise<CommentReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<CommentReadDto>(response.data);
        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    updateComment(id: number, body: CommentCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<ProblemDetails> {
        let url_ = this.baseUrl + "/Comment/UpdateComment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateComment(_response);
        });
    }

    protected processUpdateComment(response: AxiosResponse): Promise<ProblemDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
        
            return Promise.resolve<ProblemDetails>(response.data);

        }
    }

    /**
     * @return Error
     */
    deleteComment(id: number, cancelToken?: CancelToken | undefined): Promise<ProblemDetails> {
        let url_ = this.baseUrl + "/Comment/DeleteComment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteComment(_response);
        });
    }

    protected processDeleteComment(response: AxiosResponse): Promise<ProblemDetails> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<ProblemDetails>(resultdefault);

        }
    }

    /**
     * @return Success
     */
    communitiesAll( cancelToken?: CancelToken | undefined): Promise<CommunityReadDto[]> {
        let url_ = this.baseUrl + "/api/communities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };
        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
             else {
                console.log("re1");
                permanentRedirect(`http://${process.env.APP_BASEURL}`,RedirectType.replace);
            }
        })
        .then((_response: AxiosResponse) => {
            return this.processCommunitiesAll(_response);
        })

        ;
    }

    protected processCommunitiesAll(response: AxiosResponse): Promise<CommunityReadDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            return Promise.resolve<CommunityReadDto[]>(response.data);

        } else if (status !== 200 && status !== 204) {
            if(status == 400){
                console.log("re2");
                permanentRedirect(`http://${process.env.APP_BASEURL}`,RedirectType.replace);
            }
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunityReadDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    communitiesPOST(body: CommunityCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<CommunityReadDto> {
        let url_ = this.baseUrl + "/api/communities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommunitiesPOST(_response);
        });
    }

    protected processCommunitiesPOST(response: AxiosResponse): Promise<CommunityReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<CommunityReadDto>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunityReadDto>(null as any);
    }

    /**
     * @return Success
     */
    getCommunityById(id: number, cancelToken?: CancelToken | undefined): Promise<CommunityReadDto> {
        let url_ = this.baseUrl + "/api/communities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCommunityById(_response);
        });
    }

    protected processGetCommunityById(response: AxiosResponse): Promise<CommunityReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<CommunityReadDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunityReadDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    communitiesPUT(id: number, body: CommunityUpdateDto | undefined, cancelToken?: CancelToken | undefined): Promise<CommunityReadDto> {
        let url_ = this.baseUrl + "/api/communities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommunitiesPUT(_response);
        });
    }

    protected processCommunitiesPUT(response: AxiosResponse): Promise<CommunityReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = JSON.parse(resultData204);
            return Promise.resolve<CommunityReadDto>(result204);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CommunityReadDto>(null as any);
    }

    /**
     * @return No Content
     */
    communitiesDELETE(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/communities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCommunitiesDELETE(_response);
        });
    }

    protected processCommunitiesDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Error
     */
    getAllQuestion( cancelToken?: CancelToken | undefined): Promise<QuestionReadDto[]> {
        let url_ = this.baseUrl + "/Question/GetAllQuestion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                console.log("re3");
                permanentRedirect(`http://${process.env.APP_BASEURL}`,RedirectType.replace);
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllQuestion(_response);
        });
    }

    protected processGetAllQuestion(response: AxiosResponse): Promise<QuestionReadDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            if (status === 200) {
                return Promise.resolve<QuestionReadDto[]>(response.data);
    
            } else if (status !== 200 && status !== 204) {
                const _responseText = response.data;
                if(status == 400){
                    console.log("re4");
                    permanentRedirect(`http://${process.env.APP_BASEURL}`,RedirectType.replace);
                }
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }
            return Promise.resolve<QuestionReadDto[]>(null as any);
        }
    }

    /**
     * @return Error
     */
    getQuestionById(id: number, cancelToken?: CancelToken | undefined): Promise<QuestionReadDto> {
        let url_ = this.baseUrl + "/Question/GetQuestionById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetQuestionById(_response);
        });
    }

    protected processGetQuestionById(response: AxiosResponse): Promise<QuestionReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            
            return Promise.resolve<QuestionReadDto>(response.data);

        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    createQuestion(body: QuestionCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<QuestionReadDto> {
        let url_ = this.baseUrl + "/Question/CreateQuestion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateQuestion(_response);
        });
    }

    protected processCreateQuestion(response: AxiosResponse): Promise<QuestionReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<QuestionReadDto>(response.data);
        }
    }

    /**
     * @param body (optional) 
     * @return Error
     */
    updateQuestion(id: number, body: QuestionCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<QuestionReadDto> {
        let url_ = this.baseUrl + "/Question/UpdateQuestion/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateQuestion(_response);
        });
    }

    protected processUpdateQuestion(response: AxiosResponse): Promise<QuestionReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<QuestionReadDto>(response.data);
        }
    }

    /**
     * @return Error
     */
    delete(id: number, cancelToken?: CancelToken | undefined): Promise<QuestionReadDto> {
        let url_ = this.baseUrl + "/Question/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<QuestionReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = JSON.parse(resultDatadefault);
            return Promise.resolve<QuestionReadDto>(resultdefault);

        }
    }

    /**
     * @return Success
     */
    savedanswers( cancelToken?: CancelToken | undefined): Promise<SavedAnswerDto[]> {
        let url_ = this.baseUrl + "/Saves/GetSavedAnswers/savedanswers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedanswers(_response);
        });
    }

    protected processSavedanswers(response: AxiosResponse): Promise<SavedAnswerDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SavedAnswerDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavedAnswerDto[]>(null as any);
    }

    /**
     * @return Success
     */
    savedanswerGET(id: number, cancelToken?: CancelToken | undefined): Promise<SavedAnswerDto> {
        let url_ = this.baseUrl + "/Saves/GetSavedAnswerById/savedanswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedanswerGET(_response);
        });
    }

    protected processSavedanswerGET(response: AxiosResponse): Promise<SavedAnswerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<SavedAnswerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavedAnswerDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    saveanswer(body: SavedAnswerDto | undefined, cancelToken?: CancelToken | undefined): Promise<SavedAnswerDto> {
        let url_ = this.baseUrl + "/Saves/SaveAnswer/saveanswer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveanswer(_response);
        });
    }

    protected processSaveanswer(response: AxiosResponse): Promise<SavedAnswerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = JSON.parse(resultData201);
            return Promise.resolve<SavedAnswerDto>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SavedAnswerDto>(null as any);
    }

    /**
     * @return No Content
     */
    savedanswerDELETE(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Saves/DeleteSavedAnswer/savedanswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedanswerDELETE(_response);
        });
    }

    protected processSavedanswerDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Error
     */
    getAllTags( cancelToken?: CancelToken | undefined): Promise<TagReadDto[]> {
        let url_ = this.baseUrl + "/Tag/GetAllTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllTags(_response);
        });
    }

    protected processGetAllTags(response: AxiosResponse): Promise<TagReadDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<TagReadDto[]>(response.data);
        }
    }

    /**
     * @return Error
     */
    getTagById(id: number, cancelToken?: CancelToken | undefined): Promise<TagReadDto> {
        let url_ = this.baseUrl + "/Tag/GetTagById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTagById(_response);
        });
    }

    protected processGetTagById(response: AxiosResponse): Promise<TagReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        {
            return Promise.resolve<TagReadDto>(response.data);
        }
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    createTag(body: TagCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<TagReadDto> {
        let url_ = this.baseUrl + "/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTag(_response);
        });
    }

    protected processCreateTag(response: AxiosResponse): Promise<TagReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            return Promise.resolve<TagReadDto>(response.data);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagReadDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    updateTag(id: number, body: TagUpdateDto | undefined, cancelToken?: CancelToken | undefined): Promise<TagReadDto> {
        let url_ = this.baseUrl + "/Tag/UpdateTag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTag(_response);
        });
    }

    protected processUpdateTag(response: AxiosResponse): Promise<TagReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            return Promise.resolve<TagReadDto>(response.data);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagReadDto>(null as any);
    }

    /**
     * @return No Content
     */
    deleteTag(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tag/DeleteTag/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteTag(_response);
        });
    }

    protected processDeleteTag(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    addQuestionTag(body: QuestionTagCreateDto[] | undefined, cancelToken?: CancelToken | undefined): Promise<void  > {
        let url_ = this.baseUrl + "/Tag/AddQuestionTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddQuestionTag(_response);
        });
    }

    protected processAddQuestionTag(response: AxiosResponse) {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            return Promise.resolve<TagQuestionReadDto>(response.data);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TagQuestionReadDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    deleteQuestionTag(body: QuestionTagCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Tag/DeleteQuestionTag/DeleteQuestionTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteQuestionTag(_response);
        });
    }

    protected processDeleteQuestionTag(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    usersAll( cancelToken?: CancelToken | undefined): Promise<UserReadDto[]> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersAll(_response);
        });
    }

    protected processUsersAll(response: AxiosResponse): Promise<UserReadDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            return Promise.resolve<UserReadDto[]>(response.data);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserReadDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    usersPOST(body: UserCreateDto | undefined, cancelToken?: CancelToken | undefined): Promise<UserReadDto> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPOST(_response);
        });
    }

    protected processUsersPOST(response: AxiosResponse): Promise<UserReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            return Promise.resolve<UserReadDto>(response.data);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserReadDto>(null as any);
    }

    /**
     * @return Success
     */
    getUserById(id: number, cancelToken?: CancelToken | undefined): Promise<UserReadDto> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: AxiosResponse): Promise<UserReadDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<UserReadDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserReadDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    usersPUT(id: number, body: UserUpdateDto | undefined, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersPUT(_response);
        });
    }

    protected processUsersPUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    usersDELETE(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersDELETE(_response);
        });
    }

    protected processUsersDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}


export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}